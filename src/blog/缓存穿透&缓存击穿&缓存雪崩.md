## 缓存穿透，缓存击穿，缓存雪崩

### 缓存穿透 cache penetration

什么是缓存穿透?
从英文单词我们来看，penetration 是 穿透，渗透之意，我们带入理解下，特种部队在敌人没发现的情况下渗透敌人防御网，关键点：没有发现或没有抵抗；
所以什么是缓存穿透呢？

当我们发送业务请求时，通常我们是先经过缓存层，当缓存中匹配不到资源的时候，再会去下一层服务查询或者数据库查询。

以 Redis 为例，Redis 大部分情况都是通过 Key 查询对应的值，假如发送的请求传进来的 key 是不存在 Redis 中的，那么就查不到缓存，查不到缓存就会去数据库查询。假如有大量这样的请求，这些请求像“穿透”了缓存一样直接打在数据库上，这种现象就叫做缓存穿透。

什么场景下会造成缓存穿透呢？

- 缓存失效策略如果设置不合理：比如设置了大量缓存在同一时间点失效，那么将导致大量缓存数据在同一时刻发生缓存穿透，业务请求直接打到持久化存储层。

- 外部用户的恶意攻击
  外部恶意用户利用不存在的 Key，来构造大批量不存在的数据请求我们的服务，由于缓存中并不存在这些数据，因此海量请求全部穿过缓存，落在数据库中，将导致数据库崩溃。

  如何避免缓存穿透

- 合理的缓存失效策略——避免缓存数据在同一时间失效。
- 用户请求校验和限流——避免外部用户的恶意攻击。

  回到前端，前端有哪些场景下会需要缓存穿透呢？
  比如我们 npm 私服 的工具或组件包设计，如果按【包名/版本号-hash】的方式发包的时候，各业务工程也可能存在各不同版本的包，CDN 需要存我们大量的包；
  此时我们更新我们的存储结构为【包名/稳定版本标示/】当我们每次访问每个稳定版本时，默认就时最新的版本，如【test/2022.05/index.js】;要更新大版本，也需要业务手动更细依赖，如需要更新到【test/2022.06/index.js】；这样每个大版本只要保留一个版本，减少 CDN 资源量；
  但随之而来又遇到问题，我们的资源每次也会被缓存到客户端本地，当远端资源更新后，资源路径没变，客户端本地也就没法回源获取资源；怎么处理这个问题呢？
  这里就需要缓存穿透；

  所以：可行的方式有-设置更短资源的的缓存时间，通过设置 cache-control:max-age='xxx';但这样不太合理，静态资源本质上我们希望它的缓存时间更长；
  那怎么破局呢？再次更改我们的缓存设计 再加一层；
  既然静态资源不能动，那我们加一个资源的配置文件 config.json（该文件可以设置短时的缓存,cache-control:max-age='xx'），包含资源的路径信息；当我们要请求静态文件资源时，先请求 config.json，再根据 resource 的信息请求静态资源；

  ```
  config.json文件
  {
      'resource':'test/2022.06/hash01.js'
  }
  ```

  这样，每次远端发新的小版本时，更新下 config.json 文件，设置 resource 为小版本最新版本；
  即假如升级新包为'test/2022.06/hash02.js'，那 config.json 的 'resource'为'test/2022.06/hash02.js'，_此时 CDN 则需要保留 config.json 文件设置的 max-age 时间内发布的小版本；_

  这里思考一下：为什么‘此时 CDN 则需要保留 config.json 文件设置的 max-age 时间内发布的小版本？’
  这里的前提依据是上面说的 config.json 文件和目标静态资源文件设置的 cache-control:max-age='xxx'不一致；
  不一致则代表 某一个 config.json 在它缓存在客户端中的这一段时间内，它所记录的目标资源有可能失效有可能在客户端中到期，此时，客户端会根据 config.json 中的指向会再加载对应的 resource（test/2022.06/hash01.js）；则就需要保证每次更新包的时间点，往前推 config.json 设置的 max-age 值的时间内的包都需要保留；

### 缓存击穿 hotspot invalid

什么是缓存击穿？
从英文单词上，我们理解是热点失效；
请求大量的访问某个热点 Key，而这个热点 Key 在某个时刻恰好失效，导致请求全部落到数据库上。

缓存击穿和缓存穿透都是降低了整体的缓存命中率，缓存击穿可以认为是缓存穿透的一种特殊场景，所以防范措施与上面缓存穿透的措施差不多；

### 缓存雪崩 cache avalanche

当某一个时刻出现大规模的缓存失效的情况，那么就会导致大量的请求直接打在数据库上面，导致数据库压力巨大，如果在高并发的情况下，可能瞬间就会导致数据库宕机。这时候如果运维马上又重启数据库，马上又会有新的流量把数据库打死。这就是缓存雪崩。

缓存雪崩可以理解是缓存击穿的加强版，所以上面的防范措施也在这适用；此外，还需要做好缓存集群的高可用；

> 参考：<https://zhuanlan.zhihu.com/p/346651831>

```

```
