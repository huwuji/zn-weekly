### 浏览器篇

#### 一. 浏览器安全

1. 什么是 XSS?
   XSS 是跨站脚本攻击，是一种代码注入攻击；
   攻击者通过在浏览器上注入代码，并且在用户的浏览器端运行，获取用户的个人信息等；
   本质：
   网站没有对注入代码（第三方恶意代码）进行过滤，导致其和正常代码一起执行；

   危害：
   获取用户信息；流量被劫持；充当肉鸡，进行 DoS 攻击；页面结构被更改；

   > DoS 攻击是指故意的攻击网络协议实现的缺陷或直接通过野蛮手段残忍地耗尽被攻击对象的资源，目的是让目标计算机或网络无法提供正常的服务或资源访问，使目标系统服务系统停止响应甚至崩溃，

   分类：

   XSS 可以分为存储型、反射型和 DOM 型：

   - 存储型指的是恶意脚本会存储在目标服务器上，当浏览器请求数据时，脚本从服务器传回并执行。
     这种攻击常⻅于带有⽤户保存数据的⽹站功能，如论坛发帖、商品评论、⽤户私信等。
   - 反射型指的是攻击者诱导用户访问一个带有恶意代码的 URL 后，服务器端接收数据后处理，然后把带有恶意代码的数据发送到浏览器端，浏览器端解析这段带有 XSS 代码的数据后当做脚本执行，最终完成 XSS 攻击。
     反射型 XSS 漏洞常⻅于通过 URL 传递参数的功能，如⽹站搜索、跳转等。 由于需要⽤户主动打开恶意的 URL 才能⽣效，攻击者往往会结合多种⼿段诱导⽤户点击。
   - DOM 型指的通过修改页面的 DOM 节点形成的 XSS。
     DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执⾏恶意代码由浏览器端完成，属于前端 JavaScript ⾃身的安全漏洞，⽽其他两种 XSS 都属于服务端的安全漏洞。

   如何防范：
   这里主要说前端防范方式：

   - 从限制来源上，对第三方资源进行过来不，使用 CSP ，CSP 的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行，从而防止恶意代码的注入攻击。

     > CSP 指的是内容安全策略，它的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截由浏览器自己来实现。
     > 通常有两种方式来开启 CSP，一种是设置 HTTP 首部中的 Content-Security-Policy，一种是设置 meta 标签的方式

   - 对需要插入到 HTML 中的代码做好充分的转义;不让其被当成正常代码片段执行；

2. 什么是 CRSF 攻击？
   它是一种跨站请求伪造攻击。在第攻击者网站中发送被攻击站点域名的请求，利用利用 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。

   如何防范？

   - 进行同源检测，服务器根据 http 请求头中 origin 或者 referer 信息来判断请求
   - 在设置 cookie 属性的时候设置 Samesite ,限制 cookie 不能作为被第三方使用;
   - 使用 Token 进行验证

3. ⽹络劫持

- DNS 劫持:
- HTTP 劫持:由于 http 明⽂传输,运营商会修改你的 http 响应内容(即加⼴告)
  使用 HTTPS 协议

#### 二. 浏览器进程和线程

进程是 cpu 资源分配的最小单位（是能拥有资源和独立运行的最小单位）；线程是 cpu 调度的最小单位；

1. 进程通信：

每个进程的用户空间都是独立的，不能相互访问，需要借助内核空间来实现进程间通信，原因是每个进程都是共享一个内核空间。

- 管道通信：
  管道，及是内核里面的一串缓存；管道传输的数据是无格式的流且大小受限；
  管道通信是单向的，需要双向通信，则应该创建‘两个管道’。
  进程间管道通信需要 ork 创建子进程，创建的子进程会复制父进程的文件描述符，实现管道的进程间通信；

        比如 ps -ef | grep nginx 中'｜'竖线就是一个管道（匿名管道，用及完了就销毁。匿名管道是特殊的文件，只存在于内存，不存于文件系统中。）；在 Linux 中一切皆文件的理念，‘管道’也是一个文件；
        我们可以用 mkfifo 来创建具名管道，同时进行通信，通信时，只能单向通信，及 A 进行写入数据到管道后，B 进程才能读取信息，只有信息被读取完后，才能继续写入信息；

  ```
   $ echo "hello" > myPipe // 写入数据
   $ cat < myPipe // 读取管道里的数据
   hello
  ```

- 信息队列

  消息队列是保存在内核中的消息链表;

  消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销，因为进程写入数据到内核中的消息队列时，会发生从用户态拷贝数据到内核态的过程，同理另一进程读取内核中的消息数据时，会发生从内核态拷贝数据到用户态的过程。

  消息队列不适合比较大数据的传输

- 共享内存
  信息队列每次数据的写入和读取都需要经过用户态与内核态之间的拷贝过程。共享内存直接分配一个共享空间，及一块虚拟地址空间来，映射到相同的物理内存中，每个进程都可以直接访问，可以解决消息队列通信中用户态与内核态之间数据拷贝过程带来的开销；

  现代操作系统，对于内存管理，采用的是虚拟内存技术，也就是每个进程都有自己独立的虚拟内存空间，不同进程的虚拟内存映射到不同的物理内存中。所以，即使进程 A 和 进程 B 的虚拟地址是一样的，其实访问的是不同的物理内存地址，对于数据的增删查改互不影响。也不需要拷贝；提高了进程间通信的速度。

- 信号量
  多进程竞争同个共享资源会造成数据的错乱，需要信号量来保护共享资源，以确保任何时刻只能有一个进程访问共享资源，这种方式就是互斥访问。信号量不仅可以实现访问的互斥性，还可以实现进程间的同步，信号量其实是一个计数器，表示的是资源个数，其值可以通过两个原子操作来控制，分别是 P 操作和 V 操作。

- 信号
  信号是进程间通信机制中唯一的异步通信机制，信号可以在应用进程和内核之间直接交互，内核也可以利用信号来通知用户空间的进程发生了哪些系统事件，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令），一旦有信号发生，进程有三种方式响应信号 1. 执行默认操作、2. 捕捉信号、3. 忽略信号。

- Socket
  不同主机的进程间通信；
  常见的通信方式：
  一个是基于 TCP 协议的通信方式，
  一个是基于 UDP 协议的通信方式，
  一个是本地进程间通信方式。

2. Chrome 浏览器包括：

- 1 个浏览器主进程：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。
- 1 个 GPU 进程：GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。
- 1 个网络进程：主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。
- 多个渲染进程：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。
- 多个插件进程：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。

3. 渲染进程的线程

- GUI 渲染线程：负责渲染浏览器页面，对 HTML，CSS 的解析生成 DOM 树，CSSOM 树，合并生成 Render Tree,然后通过 Layout 计算生成 Layer Tree;然后通过软件和硬件绘制页面；当界面需要重绘或引发回流时，该线程也会执行。
  GUI 渲染线程和 JS 引擎线程是互斥的，当 JS 引擎执行时 GUI 线程会被挂起，GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行

- JS 引擎线程：及 JS 内核，负责解析，编译 ，执行 JS 脚本，以及管理内存，负责垃圾回收，与宿主语言的交互等；JS 引擎执行涉及浏览器的事件循环机制和任务队列，JS 线程进行是每次从任务队列获取执行任务，或者等待从任务队列中获取任务；
  浏览器一个 Tab 页中无论什么时候都只有一个 JS 引擎线程在执行；这里 WebWorker 线程不要被误解；

  > [WebWorker](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers) 线程由 JS 线程创建，但是执行在另一个上下文中，不能获取当前 Winder 上下文信息，以及操作 DOM。但可以将消息发送到创建它的 JavaScript 代码，通过将消息发布到该代码指定的事件处理程序；一个普通（专用）WebWorker 线程只能与一个页面渲染进程（Render Process）进行绑定和通信；而共享 Worker（shared Worker）可以与多个 Tab 进行绑定和通信,具体要看各浏览器的支持实现情况；属于 HTML 规范；

- 事件触发线程：
  属于浏览器而不是 JS 引擎，用来控制事件循环，可以理解为辅助 JS 线程的线程；
  当 JS 引擎执行代码块如 setTimeout 时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX 异步请求等），会将对应任务添加到事件线程中；
  当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理；

- 定时器触发器线程：
  setInterval 与 setTimeout 所在线程；浏览器定时计数器并不是由 JS 引擎计数的，因为 JS 引擎是单线程的，如果处于阻塞线程状态就会影响记计时的准确性；因此使用单独线程来计时并触发定时器，计时完毕后，添加到事件队列中，等待 JS 引擎空闲后执行，所以定时器中的任务在设定的时间点不一定能够准时执行，定时器只是在指定时间点将任务添加到事件队列中；
  W3C 在 HTML 标准中规定，定时器的定时时间不能小于 4ms，如果是小于 4ms，则默认为 4ms。

- 异步 http 请求线程
  XMLHttpRequest 连接后通过浏览器新开一个线程请求；
  检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将回调函数放入事件队列中，等待 JS 引擎空闲后执行；

4. Service Worker
   Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker 的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。
   Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求（fetch）的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。以下是这个步骤的实现：

#### 浏览器缓存

1. 强缓存：
   如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。
   强缓存策略可以通过两种方式来设置，分别是 http 头信息中的 Expires 属性和 Cache-Control 属性。

   - Expires 是 http1.0 中的方式，服务器通过在响应头中添加 Expires 属性，来指定资源的过期时间；这个时间是一个绝对时间，它是服务器的时间，因此可能存在这样的问题，就是客户端的时间和服务器端的时间不一致，或者用户可以对客户端时间进行修改的情况，这样就可能会影响缓存命中的结果。

- Cache-Control 是 http1.1 的方式，具体可设置值参考（<https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control>）
  强缓存主要通过设置 Cache-Control 的 max-age=：设置缓存的最大有效期，单位为秒
  > no-cache 和 no-store 很容易混淆：
  > no-cache 是指先要和服务器确认是否有资源更新，在进行判断。也就是说没有强缓存，但是会有协商缓存；
  > no-store 是指不使用任何缓存，每次请求都直接从服务器获取资源。

2. 协商缓存

3. 浏览器缓存位置
   按优先级：
   - Service Worker
   - Memory Cache
   - Disk Cache
   - Push Cache :它是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。并且缓存时间也很短暂，只在会话（Session）中存在，一旦会话结束就被释放；

#### 浏览器组成

浏览器可以分为两部分：内核和外壳（Shell）
shell 是指浏览器的外壳：例如菜单，工具栏等。主要是提供给用户界面操作，参数设置等等。它是调用内核来实现各种功能的。
内核是浏览器的核心。内核是基于标记语言显示内容的程序或模块。

1. 内核  
   浏览器内核主要分成两部分：
   - 渲染引擎：渲染页面，即在浏览器窗口中显示所请求的内容。默认情况下，渲染引擎可以显示 html、xml 文档及图片，它也可以借助插件显示其他类型数据，例如使用 PDF 阅读器插件，可以显示 PDF 格式。
   - JS 引擎：解析和执行 javascript 来实现网页的动态效果。

> 目前有哪些内核：  
> Blink：Chrome 的内核， Blink 引擎就是 Webkit 的一个分支；
> Webkit： Webkit 是 Safari 采用的内核；
> Gecko： 这是 Firefox 和 Flock 所采用的内核;
> Trident： IE 浏览器内核；

#### !!!!浏览器渲染

1. 渲染过程

2. 渲染优化及关键渲染路径优化
   为尽快完成首次渲染，我们需要最大限度减小以下三种可变因素：
   （1）关键资源的数量。
   （2）关键路径长度。
   （3）关键字节的数量。

3. 什么是文档的预解析？
   Webkit 和 Firefox 都做了这个优化，当执行 JavaScript 脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加载的资源。这种方式可以使资源并行加载从而使整体速度更快。需要注意的是，预解析并不改变 DOM 树，它将这个工作留给主解析过程，自己只解析外部资源的引用，比如外部脚本、样式表及图片。

4. 关于 HTML,CSS,JS 的渲染时分析？

5. !!!!每一帧的执行

> <https://mp.weixin.qq.com/s/f-ltQilq66nKUgjK3S5hnw>

#### 浏览器本地存储

1. Cookie,Local Storage,Session Storage,

SessionStorage 和 LocalStorage 都在本地进行数据存储；
SessionStorage 也有同源策略的限制，但是 SessionStorage 有一条更加严格的限制，SessionStorage 只有在同一浏览器的同一窗口下才能够共享；
LocalStorage 和 SessionStorage 都不能被爬虫爬取；
SessionStorage 具有时效性;

> 服务器端可以使用 Set-Cookie 的响应头部来配置 cookie 信息。一条 cookie 包括了 5 个属性值 expires、domain、path、secure、HttpOnly。其中 expires 指定了 cookie 失效的时间，domain 是域名、path 是路径，domain 和 path 一起限制了 cookie 能够被哪些 url 访问。secure 规定了 cookie 只能在确保安全的情况下传输，HttpOnly 规定了这个 cookie 只能被服务器访问，不能使用 js 脚本访问。

2. IndexedDB 具有以下特点：

键值对储存：IndexedDB 内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括 JavaScript 对象。对象仓库中，数据以"键值对"的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。
异步：IndexedDB 操作时不会锁死浏览器，用户依然可以进行其他操作，这与 LocalStorage 形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，拖慢网页的表现。
支持事务：IndexedDB 支持事务（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。
同源限制： IndexedDB 受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。
储存空间大：IndexedDB 的储存空间比 LocalStorage 大得多，一般来说不少于 250MB，甚至没有上限。
支持二进制储存：IndexedDB 不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer 对象和 Blob 对象）。

#### 浏览器跨域策略

同源策略：protocol（协议）、domain（域名）、port（端口）三者必须一致。

同源政策的目的主要是为了保证用户的信息安全，它只是对 js 脚本的一种限制，并不是对浏览器的限制，对于一般的 img、或者 script 脚本请求都不会有跨域的限制，这是因为这些操作都不会通过响应结果来进行可能出现安全问题的操作。

跨域请求的解决方法：

(1) CORS

> 跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器   让运行在一个 origin (domain)上的 Web 应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域 HTTP 请求。

CORS 需要浏览器和服务器同时支持，整个 CORS 过程都是浏览器完成的，无需用户参与。因此实现 CORS 的关键就是服务器，只要服务器实现了 CORS 请求，就可以跨源通信了。

浏览器将 CORS 分为简单请求和非简单请求：

1. 简单请求：
   简单请求不会触发 CORS 预检请求；

   1.1 怎么定义简单请求：

   - 请求方法是以下三种方法之一：
     HEAD
     GET
     POST
   - HTTP 的头信息不超出以下几种字段：
     Accept
     Accept-Language
     Content-Language
     Last-Event-ID
     Content-Type：只限于三个值 application/x-www-form-urlencoded、multipart/form-data、text/plain

     1.2 服务器对于简单请求的响应
     对于简单请求，浏览器会直接发出 CORS 请求，它会在请求的头信息中增加一个 Orign 字段，该字段用来说明本次请求来自哪个源（协议+端口+域名），服务器会根据这个值来决定是否同意这次请求，可直接设置

     ```
     ACCEPT-CONTROL-ALLOW-ORIGIN: *
     ```

2. 非简单请求
   非简单请求是对服务器有特殊要求的请求，比如请求方法为 DELETE 或者 PUT 等。非简单请求的 CORS 请求会在正式通信之前进行一次 HTTP 查询请求，称为预检请求。
   预检请求使用的请求方法是 OPTIONS，表示这个请求是来询问的。他的头信息中的关键字段是 Orign，表示请求来自哪个源。

   除此之外，非简单请求的 Request Headers 中必须包括如下：

   - Access-Control-Request-Method：该字段是必须的，用来列出浏览器的 CORS 请求会用到哪些 HTTP 方法。
   - Access-Control-Request-Headers： 该字段是一个逗号分隔的字符串，指定浏览器 CORS 请求会额外发送的头信息字段。

   如果需要带 Cookie，需要设置

   - withCredentials:
     - omit: 从不发送 cookies.
     - same-origin: 只有当 URL 与响应脚本同源才发送 cookies、 HTTP Basic authentication 等验证信息.(浏览器默认值，在旧版本浏览器，例如 safari 11 依旧是 omit，safari 12 已更改)
     - include: 不论是不是跨域的请求，总是发送请求资源域在本地的 cookies、 HTTP Basic authentication 等验证信息。

   同时 Response Headers 设置：

   - ACCEPT-CONTROL-ALLOW-ORIGIN 设置不能直接设置\*,必须确定的域名；
   - Access-Control-ALLOW-Method GET, POST, PUT //设置具体的方法
   - Access-Control-Allow-Headers: X-Custom-Header // 服务器支持的所有头信息字段
   - Access-Control-Allow-Credentials: true // 表示是否允许发送 Cookie

   其他注意值：

   - Access-Control-Max-Age：number。它表示预检请求的返回结果可以被缓存多久，单位是秒。该字段只对完全一样的 URL 的缓存设置生效，所以设置了缓存时间，在这个时间范围内，再次发送请求就不需要进行预检请求了。OPTIONS 请求次数过多就会损耗页面加载的性能，降低用户体验度。所以尽量要减少 OPTIONS 请求次数；

(2) JSONP
jsonp 的原理就是利用<script>标签没有跨域限制，通过<script>标签 src 属性，发送带有 callback 参数的 GET 请求，服务端将接口返回数据拼凑到 callback 函数中，返回给浏览器，浏览器解析执行，从而前端拿到 callback 函数返回的数据。

(3)postMessage 跨域
postMessage 是 HTML5 XMLHttpRequest Level 2 中的 API，且是为数不多可以跨域操作的 window 属性之一，它可用于解决以下方面的问题：

(4)Nginx 反向代理跨域和 Node 正向 代理

(5) WebSocket 协议跨域

(6)Nodejs socket 后台

#### 浏览器事件机制

1. 事件是什么？事件模型？
   事件是用户操作网页时发生的交互动作，比如 click/move， 事件除了用户触发的动作外，还可以是文档加载，窗口滚动和大小调整。事件被封装成一个 event 对象，包含了该事件发生时的所有相关信息（ event 的属性）以及可以对事件进行的操作（ event 的方法）。

事件模型：

- DOM0 级事件模型，这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实现，它可以在网页中直接定义监听函数，也可以通过 js 属性来指定监听函数。所有浏览器都兼容这种方式。直接在 dom 对象上注册事件名称，就是 DOM0 写法。

- DOM2 级事件模型，在该事件模型中，一次事件共有三个过程，第一个过程是事件捕获阶段。事件处理阶段和事件冒泡阶段。这种事件模型，事件绑定的函数是 addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。

2. 如何阻止事件冒泡

   - 普通浏览器使用：event.stopPropagation()
   - IE 浏览器使用：event.cancelBubble = true;

3. 事件委托：
   事件委托本质上是利用了浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点，父节点可以通过事件对象获取到目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件委托（事件代理）。

   事件委托的优点：

   - 减少内存消耗：不用给每个 Dom 节点绑定事件；
   - 动态绑定事件

   局限性：
   比如 focus、blur 之类的事件没有事件冒泡机制，所以无法实现事件委托；mousemove、mouseout 这样的事件，虽然有事件冒泡，但是只能不断通过位置去计算定位，对性能消耗高，因此也是不适合于事件委托的。

4. 事件循环
   js 线程从宏任务队列中获取任务执行；执行中的任务创建的宏任务根据优先级分配到宏任务队列；创建微任务进入微任务队列；当该任务执行完之后，优先执行微任务队列中的所有任务；重复开头；

   - 宏任务包括： script 脚本的执行、setTimeout ，setInterval ，setImmediate 一类的定时事件，还有如 I/O 操作、UI 渲染等。

   - 微任务包括： promise 的回调、node 中的 process.nextTick 、对 Dom 变化监听的 MutationObserver。

5. ???Node 中的 Event Loop 和浏览器中的有什么区别？

#### 浏览器垃圾回收

1. V8 的垃圾回收机制
   V8 实现了准确式 GC，GC 算法采用了分代式垃圾回收机制。因此，V8 将内存（堆）分为新生代和老生代两部分。

   - 新生代：新生代中的对象一般存活时间较短，使用 Scavenge GC 算法。分 from ,to 两个空间，每次往 form 中写数据，当 from 占满时，检查存活对象复制到 to 中，如果有失活的对象就会销毁。当复制完成后将 From 空间和 To 空间互换，这样 GC 就结束了。
   - 老生代：
     新生代中 To 空间的对象占比大小超过 25 %。在这种情况下，为了不影响到内存分配，会将对象从新生代空间移到老生代空间中。

     老生代使用标记清除算法进行垃圾回收；

     什么时候老生代会启动标记清除算法？

     - 某一个空间没有分块的时候
     - 空间中被对象超过一定限制
     - 空间不能保证新生代中的对象移动到老生代中

2. 哪些操作会造成内存泄漏？

- 第一种情况是由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。
- 第二种情况是设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。
- 第三种情况是获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。
- 第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。

> 引用
> <https://juejin.cn/post/6916157109906341902#heading-46>
